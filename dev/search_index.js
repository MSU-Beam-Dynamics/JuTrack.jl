var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API","title":"API Reference","text":"This section contains the detailed API reference for JuTrack.jl, including all modules, functions, and types. This reference is automatically generated from the docstrings in the package.\n\n","category":"section"},{"location":"api/#Modules","page":"API","title":"Modules","text":"Below are the primary modules included in JuTrack.jl.\n\nModules = [JuTrack]\nOrder = [:type, :constant, :function]","category":"section"},{"location":"api/#JuTrack.AbstractElement","page":"API","title":"JuTrack.AbstractElement","text":"AbstractElement{T}\n\nAbstract type for all elements in the lattice.\n\n\n\n\n\n","category":"type"},{"location":"api/#JuTrack.Beam","page":"API","title":"JuTrack.Beam","text":"Beam\n\nA struct that contains the information of a beam. The struct contains the following fields:\n\nr::Matrix{Float64}: Nx6 matrix of the 6D phase space coordinates of the beam particles.\nnp::Int: Number of particles.\nnmacro::Int: Number of macro particles.\nenergy::Float64: Energy of the beam in eV.\nlost_flag::Vector{Int}: Vector of length nmacro that contains the lost flag of each particle.\ncharge::Float64: Charge of the beam particles. -1.0 for electrons.\nmass::Float64: Mass of the beam in eV.\ngamma::Float64: Lorentz factor of the beam particles.\nbeta::Float64: Velocity of the beam particles in units of the speed of light.\natomnum::Float64: Atomic number of the beam particles.\nclassrad0::Float64: Classical radiation constant. (not used)\nradconst::Float64: Radiation constant. (not used)\nT0::Float64: Revolution period of the beam particles. (not used)\nnturn::Int: Number of turns in the simulation. (not used)\nznbin::Int: Number of bins in the z direction.\ninzindex::Vector{Int}: Index of the z bin.\nzhist::Vector{Float64}: Histogram of the z direction.\nzhist_edges::Vector{Float64}: Edges of the z histogram.\ntemp1::Vector{Float64}: Temporary variable.\ntemp2::Vector{Float64}: Temporary variable.\ntemp3::Vector{Float64}: Temporary variable.\ntemp4::Vector{Float64}: Temporary variable.\ntemp5::Vector{Float64}: Temporary variable.\nemittance::Vector{Float64}: Emittance in x, y, z directions.\ncentroid::Vector{Float64}: Centroid in x, px, y, py, z, pz directions.\nmoment2nd::Matrix{Float64}: 2nd momentum matrix.\nbeamsize::Vector{Float64}: Beam size in x, px, y, py, z, pz directions.\ncurrent::Float64: Beam current for space charge calculation in A.\n\n\n\n\n\n","category":"type"},{"location":"api/#JuTrack.Beam-Tuple{Matrix{Float64}, Float64}","page":"API","title":"JuTrack.Beam","text":"Beam(r::Matrix{Float64}, energy::Float64; np::Int=size(r, 1), charge::Float64=-1.0, mass::Float64=m_e, atn::Float64=1.0,\n    emittance::Vector{Float64}=zeros(Float64, 3), centroid::Vector{Float64}=zeros(Float64, 6), T0::Float64=0.0, znbin::Int=99, \n    current::Float64=0.0)\n\nConstruct a Beam object with coordinates of particles and beam energy. Other parameters are optional.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.Beam-Tuple{Matrix{Float64}}","page":"API","title":"JuTrack.Beam","text":"Beam(r::Matrix{Float64}; energy::Float64=1e9,np::Int=size(r, 1), charge::Float64=-1.0, mass::Float64=m_e, atn::Float64=1.0,         emittance::Vector{Float64}=zeros(Float64, 3), centroid::Vector{Float64}=zeros(Float64, 6), T0::Float64=0.0, znbin::Int=99,          current::Float64=0.0)\n\nConstruct a Beam object with particle coordinates. Other parameters are optional.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.Beam-Tuple{}","page":"API","title":"JuTrack.Beam","text":"Beam(;r::Matrix{Float64}=zeros(Float64, 1,6), energy::Float64=1e9, np::Int=size(r, 1), charge::Float64=-1.0, mass::Float64=m_e, \natn::Float64=1.0, emittance::Vector{Float64}=zeros(Float64, 3), centroid::Vector{Float64}=zeros(Float64, 6), T0::Float64=0.0, \nznbin::Int=99, current::Float64=0.0)\n\nConstruct a Beam object with default parameters. All parameters are optional.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.Beam-Union{Tuple{Array{DTPSAD{N, T}, 2}}, Tuple{T}, Tuple{N}} where {N, T<:Number}","page":"API","title":"JuTrack.Beam","text":"Beam(r_GTPS::Matrix{DTPSAD{N, T}}; energy::Float64=1e9, np::Int=size(r_GTPS, 1), charge::Float64=-1.0, mass::Float64=m_e, \natn::Float64=1.0, emittance::Vector{Float64}=zeros(Float64, 3), centroid::Vector{Float64}=zeros(Float64, 6), T0::Float64=0.0, \nznbin::Int=99, current::Float64=0.0) where {N, T <: Number}\n\nConstruct a Beam object with coordinates of particles in TPSA (DTPSAD type) format. Other parameters are optional.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.Beam-Union{Tuple{Beam{T}}, Tuple{T}} where T","page":"API","title":"JuTrack.Beam","text":"Beam(beam::Beam)\n\nCopy a Beam object.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.CORRECTOR","page":"API","title":"JuTrack.CORRECTOR","text":"CORRECTOR(;name::String = \"CORRECTOR\", len::Float64 = 0.0, xkick::Float64 = 0.0, ykick::Float64 = 0.0, \n    T1::Array{Float64,1} = zeros(6), T2::Array{Float64,1} = zeros(6), R1::Array{Float64,2} = zeros(6,6), \n    R2::Array{Float64,2} = zeros(6,6))\n\nA corrector element. Example:\n\ncorrector = CORRECTOR(name=\"C1\", len=0.5, xkick=1e-3)\n\n\n\n\n\n","category":"type"},{"location":"api/#JuTrack.CRABCAVITY","page":"API","title":"JuTrack.CRABCAVITY","text":"CRABCAVITY(;name::String = \"CRABCAVITY\", len::Float64 = 0.0, volt::Float64 = 0.0, freq::Float64 = 0.0, \n    phi::Float64 = 0.0, errors::Array{Float64,1} = zeros(2), energy::Float64 = 1e9)\n\nA crab cavity element. Example:\n\ncrab = CRABCAVITY(name=\"CRAB1\", len=0.5, volt=1e6, freq=1e6)\n\n\n\n\n\n","category":"type"},{"location":"api/#JuTrack.DRIFT","page":"API","title":"JuTrack.DRIFT","text":"DRIFT(;name::String = \"DRIFT\", len::Float64 = 0.0, T1::Array{Float64,1} = zeros(6), \n    T2::Array{Float64,1} = zeros(6), R1::Array{Float64,2} = zeros(6,6), R2::Array{Float64,2} = zeros(6,6), \n    RApertures::Array{Float64,1} = zeros(6), EApertures::Array{Float64,1} = zeros(6))\n\nA drift element.\n\nArguments\n\nname::String: element name\nlen::Float64: element length\nT1::Array{Float64,1}: misalignment at entrance\nT2::Array{Float64,1}: misalignment at exit\nR1::Array{Float64,2}: rotation at entrance\nR2::Array{Float64,2}: rotation at exit\nRApertures::Array{Float64,1}: rectangular apertures. Not implemented yet.\nEApertures::Array{Float64,1}: elliptical apertures. Not implemented yet.\n\nExample:\n\ndrift = DRIFT(name=\"D1\", len=1.0)\n\n\n\n\n\n","category":"type"},{"location":"api/#JuTrack.DRIFT_SC","page":"API","title":"JuTrack.DRIFT_SC","text":"DRIFT_SC(;name::String = \"DRIFT_SC\", len::Float64 = 0.0, T1::Array{Float64,1} = zeros(6), \n    T2::Array{Float64,1} = zeros(6), R1::Array{Float64,2} = zeros(6,6), R2::Array{Float64,2} = zeros(6,6), \n    RApertures::Array{Float64,1} = zeros(6), EApertures::Array{Float64,1} = zeros(6), a::Float64 = 1.0, b::Float64 = 1.0,\n    Nl::Int64 = 10, Nm::Int64 = 10, Nsteps::Int64=1)\n\nA drift element with space charge.\n\nArguments\n\nname::String: element name\nlen::Float64: element length\nT1::Array{Float64,1}: misalignment at entrance\nT2::Array{Float64,1}: misalignment at exit\nR1::Array{Float64,2}: rotation at entrance\nR2::Array{Float64,2}: rotation at exit\nRApertures::Array{Float64,1}: rectangular apertures. Not implemented yet.\nEApertures::Array{Float64,1}: elliptical apertures. Not implemented yet.\na::Float64: horizontal size of the perfectly conducting pipe\nb::Float64: vertical size of the perfectly conducting pipe\nNl::Int64: number of mode in the horizontal direction\nNm::Int64: number of mode in the vertical direction\nNsteps::Int64: number of steps for space charge calculation. One step represents a half-kick-half.\n\nExample:\n\ndrift = DRIFT_SC(name=\"D1_SC\", len=0.5, a=13e-3, b=13e-3, Nl=15, Nm=15)\n\n\n\n\n\n","category":"type"},{"location":"api/#JuTrack.DrivingTerms","page":"API","title":"JuTrack.DrivingTerms","text":"DrivenTerms\n\nStructure to store the driving terms for the resonance driving terms calculation.\n\nArguments\n\nh21000::Vector{Float64}: Driving term h21000.\nh30000::Vector{Float64}: Driving term h30000.\nh10110::Vector{Float64}: Driving term h10110.\n\n...\n\nh00310::Vector{Float64}: Driving term h00310.\nh00400::Vector{Float64}: Driving term h00400.\n\n\n\n\n\n","category":"type"},{"location":"api/#JuTrack.DrivingTermsTPSAD","page":"API","title":"JuTrack.DrivingTermsTPSAD","text":"DrivingTermsTPSAD{N}\n\nStructure to store the driving terms for the resonance driving terms calculation with DTPSAD.\n\nArguments\n\nh21000::Vector{DTPSAD{N, Float64}}: Driving term h21000.\nh30000::Vector{DTPSAD{N, Float64}}: Driving term h30000.\nh10110::Vector{DTPSAD{N, Float64}}: Driving term h10110.\n\n...\n\nh00310::Vector{DTPSAD{N, Float64}}: Driving term h00310.\nh00400::Vector{DTPSAD{N, Float64}}: Driving term h00400.\n\n\n\n\n\n","category":"type"},{"location":"api/#JuTrack.EdwardsTengTwiss-Tuple{Float64, Float64}","page":"API","title":"JuTrack.EdwardsTengTwiss","text":"EdwardsTengTwiss(betax::Float64, betay::Float64; alphax::Float64=0.0, alphay::Float64=0.0,\ndx::Float64=0.0, dy::Float64=0.0, dpx::Float64=0.0, dpy::Float64=0.0,\nmux::Float64=0.0, muy::Float64=0.0,\nR11::Float64=0.0, R12::Float64=0.0, R21::Float64=0.0, R22::Float64=0.0,\nmode::Int=1)\n\nConstruct a EdwardsTengTwiss object with betax and betay. All other parameters are optional.\n\nArguments\n\nbetax::Float64: Horizontal beta function.\nbetay::Float64: Vertical beta function.\nalphax::Float64=0.0: Horizontal alpha function.\nalphay::Float64=0.0: Vertical alpha function.\ndx::Float64=0.0: Horizontal dispersion.\ndy::Float64=0.0: Vertical dispersion.\ndpx::Float64=0.0: derivative of horizontal dispersion.\ndpy::Float64=0.0: derivative of vertical dispersion.\nmux::Float64=0.0: Horizontal phase advance.\nmuy::Float64=0.0: Vertical phase advance.\nR11::Float64=0.0: Matrix Element R11.\nR12::Float64=0.0: Matrix Element R12.\nR21::Float64=0.0: Matrix Element R21.\nR22::Float64=0.0: Matrix Element R22.\nmode::Int=1: mode for calculation.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.EdwardsTengTwiss-Union{Tuple{T}, Tuple{N}, Tuple{DTPSAD{N, T}, DTPSAD{N, T}}} where {N, T<:Number}","page":"API","title":"JuTrack.EdwardsTengTwiss","text":"EdwardsTengTwiss(betax::DTPSAD{N,T}, betay::DTPSAD{N,T}; \n\talphax::DTPSAD{N,T}=zero(DTPSAD{N,T}),\n\talphay::DTPSAD{N,T}=zero(DTPSAD{N,T}),\n\tdx::DTPSAD{N,T}=zero(DTPSAD{N,T}),\n\tdy::DTPSAD{N,T}=zero(DTPSAD{N,T}),\n\tdpx::DTPSAD{N,T}=zero(DTPSAD{N,T}),\n\tdpy::DTPSAD{N,T}=zero(DTPSAD{N,T}),\n\tmux::DTPSAD{N,T}=zero(DTPSAD{N,T}),\n\tmuy::DTPSAD{N,T}=zero(DTPSAD{N,T}),\n\tR11::DTPSAD{N,T}=zero(DTPSAD{N,T}),\n\tR12::DTPSAD{N,T}=zero(DTPSAD{N,T}),\n\tR21::DTPSAD{N,T}=zero(DTPSAD{N,T}),\n\tR22::DTPSAD{N,T}=zero(DTPSAD{N,T}),\n\tmode::Int=1) where {N, T <: Number}\n\nConstruct a EdwardsTengTwiss object with betax and betay in TPSA (DTPSAD type) format. All other parameters are optional.\n\nArguments\n\nbetax::DTPSAD{N,T}: Horizontal beta function.\nbetay::DTPSAD{N,T}: Vertical beta function.\nalphax::DTPSAD{N,T}=zero(DTPSAD{N,T}): Horizontal alpha function.\nalphay::DTPSAD{N,T}=zero(DTPSAD{N,T}): Vertical alpha function.\ndx::DTPSAD{N,T}=zero(DTPSAD{N,T}): Horizontal dispersion.\ndy::DTPSAD{N,T}=zero(DTPSAD{N,T}): Vertical dispersion.\ndpx::DTPSAD{N,T}=zero(DTPSAD{N,T}): derivative of horizontal dispersion.\ndpy::DTPSAD{N,T}=zero(DTPSAD{N,T}): derivative of vertical dispersion.\nmux::DTPSAD{N,T}=zero(DTPSAD{N,T}): Horizontal phase advance.\nmuy::DTPSAD{N,T}=zero(DTPSAD{N,T}): Vertical phase advance.\nR11::DTPSAD{N,T}=zero(DTPSAD{N,T}): Matrix Element R11.\nR12::DTPSAD{N,T}=zero(DTPSAD{N,T}): Matrix Element R12.\nR21::DTPSAD{N,T}=zero(DTPSAD{N,T}): Matrix Element R21.\nR22::DTPSAD{N,T}=zero(DTPSAD{N,T}): Matrix Element R22.\nmode::Int=1: mode for calculation.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.KOCT","page":"API","title":"JuTrack.KOCT","text":"KOCT(;name::String = \"OCT\", len::Float64 = 0.0, k0::Float64 = 0.0, k1::Float64 = 0.0, k2::Float64 = 0.0, k3::Float64 = 0.0, \n    PolynomA::Array{Float64,1} = zeros(Float64, 4),  \n    MaxOrder::Int64=3, NumIntSteps::Int64 = 10, rad::Int64=0, FringeQuadEntrance::Int64 = 0, \n    FringeQuadExit::Int64 = 0, T1::Array{Float64,1} = zeros(Float64, 6), \n    T2::Array{Float64,1} = zeros(Float64, 6), R1::Array{Float64,2} = zeros(Float64, 6, 6), \n    R2::Array{Float64,2} = zeros(Float64, 6, 6), RApertures::Array{Float64,1} = zeros(Float64, 6), \n    EApertures::Array{Float64,1} = zeros(Float64, 6), KickAngle::Array{Float64,1} = zeros(Float64, 2))\n\nA canonical octupole element. Example:\n\noct = KOCT(name=\"O1\", len=0.5, k3=0.5)\n\n\n\n\n\n","category":"type"},{"location":"api/#JuTrack.KOCT_SC","page":"API","title":"JuTrack.KOCT_SC","text":"KOCT_SC(;name::String = \"OCT\", len::Float64 = 0.0, k0::Float64 = 0.0, k1::Float64 = 0.0, k2::Float64 = 0.0, k3::Float64 = 0.0, \n    PolynomA::Array{Float64,1} = zeros(Float64, 4),  \n    MaxOrder::Int64=3, NumIntSteps::Int64 = 10, rad::Int64=0, FringeQuadEntrance::Int64 = 0, \n    FringeQuadExit::Int64 = 0, T1::Array{Float64,1} = zeros(Float64, 6), \n    T2::Array{Float64,1} = zeros(Float64, 6), R1::Array{Float64,2} = zeros(Float64, 6, 6), \n    R2::Array{Float64,2} = zeros(Float64, 6, 6), RApertures::Array{Float64,1} = zeros(Float64, 6),\n    EApertures::Array{Float64,1} = zeros(Float64, 6), KickAngle::Array{Float64,1} = zeros(Float64, 2),\n    a::Float64 = 1.0, b::Float64 = 1.0, Nl::Int64 = 10, Nm::Int64 = 10, Nsteps::Int64=1)\n\nA canonical octupole element with space charge. Example:\n\noct = KOCT_SC(name=\"O1_SC\", len=0.5, k3=0.5, a=13e-3, b=13e-3, Nl=15, Nm=15)\n\n\n\n\n\n","category":"type"},{"location":"api/#JuTrack.KQUAD","page":"API","title":"JuTrack.KQUAD","text":"KQUAD(;name::String = \"Quad\", len::Float64 = 0.0, k1::Float64 = 0.0, \n    PolynomA::Array{Float64,1} = zeros(Float64, 4), \n    MaxOrder::Int64=1, NumIntSteps::Int64 = 10, rad::Int64=0, FringeQuadEntrance::Int64 = 0, \n    FringeQuadExit::Int64 = 0, T1::Array{Float64,1} = zeros(Float64, 6), \n    T2::Array{Float64,1} = zeros(Float64, 6), R1::Array{Float64,2} = zeros(Float64, 6, 6), \n    R2::Array{Float64,2} = zeros(Float64, 6, 6), RApertures::Array{Float64,1} = zeros(Float64, 6), \n    EApertures::Array{Float64,1} = zeros(Float64, 6), KickAngle::Array{Float64,1} = zeros(Float64, 2))\n\nA canonical quadrupole element.\n\nExample:\n\nquad = KQUAD(name=\"Q1\", len=0.5, k1=0.5)\n\n\n\n\n\n","category":"type"},{"location":"api/#JuTrack.KQUAD_SC","page":"API","title":"JuTrack.KQUAD_SC","text":"KQUAD_SC(;name::String = \"Quad\", len::Float64 = 0.0, k0::Float64 = 0.0, k1::Float64 = 0.0, k2::Float64 = 0.0, k3::Float64 = 0.0,\n    PolynomA::Array{Float64,1} = zeros(Float64, 4), \n    MaxOrder::Int64=1, NumIntSteps::Int64 = 10, rad::Int64=0, FringeQuadEntrance::Int64 = 0, \n    FringeQuadExit::Int64 = 0, T1::Array{Float64,1} = zeros(Float64, 6), \n    T2::Array{Float64,1} = zeros(Float64, 6), R1::Array{Float64,2} = zeros(Float64, 6, 6), \n    R2::Array{Float64,2} = zeros(Float64, 6, 6), RApertures::Array{Float64,1} = zeros(Float64, 6), \n    EApertures::Array{Float64,1} = zeros(Float64, 6), KickAngle::Array{Float64,1} = zeros(Float64, 2),\n    a::Float64 = 1.0, b::Float64 = 1.0, Nl::Int64 = 10, Nm::Int64 = 10, Nsteps::Int64=1)\n\nA canonical quadrupole element with space charge. Example:\n\nquad = KQUAD_SC(name=\"Q1_SC\", len=0.5, k1=0.5, a=13e-3, b=13e-3, Nl=15, Nm=15)\n\n\n\n\n\n","category":"type"},{"location":"api/#JuTrack.KSEXT","page":"API","title":"JuTrack.KSEXT","text":"KSEXT(;name::String = \"Sext\", len::Float64 = 0.0, k0::Float64 = 0.0, k1::Float64 = 0.0, k2::Float64 = 0.0, k3::Float64 = 0.0, \n    PolynomA::Array{Float64,1} = zeros(Float64, 4), \n    MaxOrder::Int64=2, NumIntSteps::Int64 = 10, rad::Int64=0, FringeQuadEntrance::Int64 = 0, \n    FringeQuadExit::Int64 = 0, T1::Array{Float64,1} = zeros(Float64, 6), \n    T2::Array{Float64,1} = zeros(Float64, 6), R1::Array{Float64,2} = zeros(Float64, 6, 6), \n    R2::Array{Float64,2} = zeros(Float64, 6, 6), RApertures::Array{Float64,1} = zeros(Float64, 6), \n    EApertures::Array{Float64,1} = zeros(Float64, 6), KickAngle::Array{Float64,1} = zeros(Float64, 2))\n\nA canonical sextupole element. Example:\n\nsext = KSEXT(name=\"S1\", len=0.5, k2=0.5)\n\n\n\n\n\n","category":"type"},{"location":"api/#JuTrack.KSEXT_SC","page":"API","title":"JuTrack.KSEXT_SC","text":"KSEXT_SC(;name::String = \"Sext\", len::Float64 = 0.0, k0::Float64 = 0.0, k1::Float64 = 0.0, k2::Float64 = 0.0, k3::Float64 = 0.0, \n    PolynomA::Array{Float64,1} = zeros(Float64, 4), \n    MaxOrder::Int64=2, NumIntSteps::Int64 = 10, rad::Int64=0, FringeQuadEntrance::Int64 = 0, \n    FringeQuadExit::Int64 = 0, T1::Array{Float64,1} = zeros(Float64, 6), \n    T2::Array{Float64,1} = zeros(Float64, 6), R1::Array{Float64,2} = zeros(Float64, 6, 6), \n    R2::Array{Float64,2} = zeros(Float64, 6, 6), RApertures::Array{Float64,1} = zeros(Float64, 6),\n    EApertures::Array{Float64,1} = zeros(Float64, 6), KickAngle::Array{Float64,1} = zeros(Float64, 2),\n    a::Float64 = 1.0, b::Float64 = 1.0, Nl::Int64 = 10, Nm::Int64 = 10, Nsteps::Int64=1)\n\nA canonical sextupole element with space charge. Example:\n\nsext = KSEXT_SC(name=\"S1_SC\", len=0.5, k2=0.5, a=13e-3, b=13e-3, Nl=15, Nm=15)\n\n\n\n\n\n","category":"type"},{"location":"api/#JuTrack.LBEND","page":"API","title":"JuTrack.LBEND","text":"LBEND(;name::String = \"Bend\", len::Float64 = 0.0, angle::Float64 = 0.0, e1::Float64 = 0.0, e2::Float64 = 0.0, K::Float64 = 0.0,\n    fint1::Float64 = 0.0, fint2::Float64 = 0.0, FullGap::Float64 = 0.0,\n    T1::Array{Float64,1} = zeros(Float64, 6), T2::Array{Float64,1} = zeros(Float64, 6), R1::Array{Float64,2} = zeros(Float64, 6, 6), \n    R2::Array{Float64,2} = zeros(Float64, 6, 6), RApertures::Array{Float64,1} = zeros(Float64, 6), EApertures::Array{Float64,1} = zeros(Float64, 6))\n\nA sector bending magnet with linear map. Example:\n\nbend = LBEND(name=\"B1\", len=0.5, angle=0.5)\n\n\n\n\n\n","category":"type"},{"location":"api/#JuTrack.LongitudinalRLCWake","page":"API","title":"JuTrack.LongitudinalRLCWake","text":"LongitudinalRLCWake(;freq::Float64=1.0e9, Rshunt::Float64=1.0e6, Q0::Float64=1.0)\n\nA longitudinal RLC wake element.\n\n\n\n\n\n","category":"type"},{"location":"api/#JuTrack.LongitudinalWake","page":"API","title":"JuTrack.LongitudinalWake","text":"LongitudinalWake(times::AbstractVector, wakefields::AbstractVector, wakefield::Function)\n\nCreate longitudinal wake element.\n\nArguments\n\ntimes::AbstractVector: time points\nwakefields::AbstractVector: wakefield values at the time points\nfliphalf::Float64=-1.0: flip the wakefield for positrons if needed\n\nReturns\n\nLongitudinalWake: the created longitudinal wake element\n\n\n\n\n\n","category":"type"},{"location":"api/#JuTrack.MARKER","page":"API","title":"JuTrack.MARKER","text":"MARKER(;name::String = \"MARKER\", len::Float64 = 0.0)\n\nA marker element. Example:\n\nmarker = MARKER(name=\"MARKER1\")\n\n\n\n\n\n","category":"type"},{"location":"api/#JuTrack.QUAD","page":"API","title":"JuTrack.QUAD","text":"QUAD(;name::String = \"Quad\", len::Float64 = 0.0, k1::Float64 = 0.0, rad::Int64 = 0, \n    T1::Array{Float64,1} = zeros(6), T2::Array{Float64,1} = zeros(6), R1::Array{Float64,2} = zeros(6,6), \n    R2::Array{Float64,2} = zeros(6,6), RApertures::Array{Float64,1} = zeros(6), EApertures::Array{Float64,1} = zeros(6))\n\nA quadrupole element using matrix formalism. Example:\n\nquad = QUAD(name=\"Q1\", len=0.5, k1=1.0)\n\n\n\n\n\n","category":"type"},{"location":"api/#JuTrack.QUAD_SC","page":"API","title":"JuTrack.QUAD_SC","text":"QUAD_SC(;name::String = \"Quad\", len::Float64 = 0.0, k1::Float64 = 0.0, rad::Int64 = 0, \n    T1::Array{Float64,1} = zeros(6), T2::Array{Float64,1} = zeros(6), R1::Array{Float64,2} = zeros(6,6), \n    R2::Array{Float64,2} = zeros(6,6), RApertures::Array{Float64,1} = zeros(6), EApertures::Array{Float64,1} = zeros(6), \n    a::Float64 = 1.0, b::Float64 = 1.0, Nl::Int64 = 10, Nm::Int64 = 10, Nsteps::Int64=1)\n\nA quadrupole element with space charge. Example:\n\nquad = QUAD_SC(name=\"Q1_SC\", len=0.5, k1=1.0, a=13e-3, b=13e-3, Nl=15, Nm=15)\n\n\n\n\n\n","category":"type"},{"location":"api/#JuTrack.RFCA","page":"API","title":"JuTrack.RFCA","text":"RFCA(;name::String = \"RFCA\", len::Float64 = 0.0, volt::Float64 = 0.0, freq::Float64 = 0.0, h::Float64 = 1.0, \n    lag::Float64 = 0.0, philag::Float64 = 0.0, energy::Float64 = 0.0)\n\nA RF cavity element. Example:\n\nrf = RFCA(name=\"RF1\", len=0.5, volt=1e6, freq=1e6)\n\n\n\n\n\n","category":"type"},{"location":"api/#JuTrack.SBEND","page":"API","title":"JuTrack.SBEND","text":"SBEND(;name::String = \"SBend\", len::Float64 = 0.0, angle::Float64 = 0.0, e1::Float64 = 0.0, e2::Float64 = 0.0, \n    PolynomA::Array{Float64,1} = zeros(Float64, 4), PolynomB::Array{Float64,1} = zeros(Float64, 4), \n    MaxOrder::Int64=0, NumIntSteps::Int64 = 10, rad::Int64=0, fint1::Float64 = 0.0, fint2::Float64 = 0.0, \n    gap::Float64 = 0.0, FringeBendEntrance::Int64 = 1, FringeBendExit::Int64 = 1, FringeQuadEntrance::Int64 = 0, \n    FringeQuadExit::Int64 = 0, FringeIntM0::Array{Float64,1} = zeros(Float64, 5), FringeIntP0::Array{Float64,1} = zeros(Float64, 5), \n    T1::Array{Float64,1} = zeros(Float64, 6), T2::Array{Float64,1} = zeros(Float64, 6), R1::Array{Float64,2} = zeros(Float64, 6, 6), \n    R2::Array{Float64,2} = zeros(Float64, 6, 6), RApertures::Array{Float64,1} = zeros(Float64, 6), EApertures::Array{Float64,1} = zeros(Float64, 6), \n    KickAngle::Array{Float64,1} = zeros(Float64, 2))\n\nA sector bending magnet. Example:\n\nbend = SBEND(name=\"B1\", len=0.5, angle=0.5)\n\n\n\n\n\n","category":"type"},{"location":"api/#JuTrack.SBEND_SC","page":"API","title":"JuTrack.SBEND_SC","text":"SBEND_SC(;name::String = \"SBend\", len::Float64 = 0.0, angle::Float64 = 0.0, e1::Float64 = 0.0, e2::Float64 = 0.0, \n    PolynomA::Array{Float64,1} = zeros(Float64, 4), PolynomB::Array{Float64,1} = zeros(Float64, 4), \n    MaxOrder::Int64=0, NumIntSteps::Int64 = 10, rad::Int64=0, fint1::Float64 = 0.0, fint2::Float64 = 0.0, \n    gap::Float64 = 0.0, FringeBendEntrance::Int64 = 1, FringeBendExit::Int64 = 1, \n    FringeQuadEntrance::Int64 = 0, FringeQuadExit::Int64 = 0, FringeIntM0::Array{Float64,1} = zeros(Float64, 5), \n    FringeIntP0::Array{Float64,1} = zeros(Float64, 5), T1::Array{Float64,1} = zeros(Float64, 6), \n    T2::Array{Float64,1} = zeros(Float64, 6), R1::Array{Float64,2} = zeros(Float64, 6, 6), \n    R2::Array{Float64,2} = zeros(Float64, 6, 6), RApertures::Array{Float64,1} = zeros(Float64, 6), \n    EApertures::Array{Float64,1} = zeros(Float64, 6), KickAngle::Array{Float64,1} = zeros(Float64, 2),\n    a::Float64 = 1.0, b::Float64 = 1.0, Nl::Int64 = 10, Nm::Int64 = 10, Nsteps::Int64=1)\n\nA sector bending magnet with space charge. Example:\n\nbend = SBEND_SC(name=\"B1_SC\", len=0.5, angle=0.5, a=13e-3, b=13e-3, Nl=15, Nm=15)\n\n\n\n\n\n","category":"type"},{"location":"api/#JuTrack.SOLENOID","page":"API","title":"JuTrack.SOLENOID","text":"SOLENOID(;name::String = \"Solenoid\", len::Float64 = 0.0, ks::Float64 = 0.0, T1::Array{Float64,1} = zeros(6), \n    T2::Array{Float64,1} = zeros(6), R1::Array{Float64,2} = zeros(6,6), R2::Array{Float64,2} = zeros(6,6))\n\nA solenoid element. Example:\n\nsolenoid = SOLENOID(name=\"S1\", len=0.5, ks=1.0)\n\n\n\n\n\n","category":"type"},{"location":"api/#JuTrack.StrongGaussianBeam","page":"API","title":"JuTrack.StrongGaussianBeam","text":"StrongGaussianBeam(charge::Float64, mass::Float64, atomnum::Float64, np::Int, energy::Float64, \nop::AbstractOptics4D, bs::Vector{Float64}, nz::Int)\n\nConstruct a strong beam-beam element with Gaussian distribution.\n\nArguments\n\ncharge::Float64: charge of the particle\nmass::Float64: mass of the particle\natomnum::Float64: atomic number of the particle\nnp::Int: number of particles in the beam\nenergy::Float64: total energy of the beam\nop::AbstractOptics4D: optics at the interaction point\nbs::Vector{Float64}: beam size at the interaction point\nnz::Int: number of slices in z direction\n\nReturns\n\nStrongGaussianBeam: strong beam-beam element with Gaussian distribution\n\n\n\n\n\n","category":"type"},{"location":"api/#JuTrack.WIGGLER","page":"API","title":"JuTrack.WIGGLER","text":"WIGGLER(;name::String = \"WIGGLER\", len::Float64 = 0.0, lw::Float64 = 0.0, Bmax::Float64 = 0.0, \n        Nsteps::Int64 = 10, By::Array{Int} = [1;1;0;1;1;0], Bx::Array{Int} = Int[], energy::Float64 = 1e9,\n        R1::Array{Float64,2} = zeros(6,6), R2::Array{Float64,2} = zeros(6,6), \n        T1::Array{Float64,1} = zeros(6), T2::Array{Float64,1} = zeros(6))\n\nA wiggler element.\n\narameters:\nlen: total length of the wiggler (m)\nlw: period length of the wiggler (m)\nBmax: Peak magnetic field (T)\nNsteps: number of integration steps\nBy: wiggler harmonics for horizontal wigglers. Default [1;1;0;1;1;0]\nBx: wiggler harmonics for vertical wigglers. Default []\nenergy: reference energy (eV)\n\nExample:\n\nwiggler = WIGGLER(name=\"W1\", len=1.0, lw=0.1, Bmax=1.0)\n\n\n\n\n\n","category":"type"},{"location":"api/#JuTrack.optics4DUC-NTuple{4, Float64}","page":"API","title":"JuTrack.optics4DUC","text":"optics4DUC(bx::Float64, ax::Float64, by::Float64, ay::Float64)\n\nConstruct a 4D optics element with uncoupled optics.\n\nArguments\n\nbx::Float64: beta function in x direction\nax::Float64: alpha function in x direction\nby::Float64: beta function in y direction\nay::Float64: alpha function in y direction\n\nReturns\n\noptics4DUC: 4D optics element with uncoupled optics\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.thinMULTIPOLE","page":"API","title":"JuTrack.thinMULTIPOLE","text":"thinMULTIPOLE(;name::String = \"thinMULTIPOLE\", len::Float64 = 0.0, PolynomA::Array{Float64,1} = zeros(Float64, 4), \n    PolynomB::Array{Float64,1} = zeros(Float64, 4), MaxOrder::Int64=1, NumIntSteps::Int64 = 1, rad::Int64=0, \n    FringeQuadEntrance::Int64 = 0, FringeQuadExit::Int64 = 0, T1::Array{Float64,1} = zeros(Float64, 6), \n    T2::Array{Float64,1} = zeros(Float64, 6), R1::Array{Float64,2} = zeros(Float64, 6, 6), \n    R2::Array{Float64,2} = zeros(Float64, 6, 6), RApertures::Array{Float64,1} = zeros(Float64, 6), \n    EApertures::Array{Float64,1} = zeros(Float64, 6), KickAngle::Array{Float64,1} = zeros(Float64, 2))\n\nA thin multipole element. PolynomA and PolynomB are the skew and normal components of the multipole.\n\nExample:\n\nmultipole = thinMULTIPOLE(name=\"M1\", len=0.5, PolynomA=[0.0, 0.0, 0.0, 0.0], PolynomB=[0.0, 0.0, 0.0, 0.0])\n\n\n\n\n\n","category":"type"},{"location":"api/#JuTrack.ADcomputeRDT-NTuple{4, Any}","page":"API","title":"JuTrack.ADcomputeRDT","text":"ADcomputeRDT(ring, index, changed_ids, changed_elems; chromatic=true, coupling=true, geometric1=true, geometric2=true, tuneshifts=true)\n\nCompute Hamiltonian resonance driving terms (RDTs). This function is used for auto-differentiation with Enzyme to avoid issues with mutable structs.\n\nArguments\n\nring::Array: lattice sequence\nindex::Int: index of the element to compute the RDTs\nchanged_ids::Vector{Int}: IDs of the elements with changed parameters\nchanged_elems::Vector{Element}: elements with changed parameters\nchromatic::Bool=true: flag to compute chromatic RDTs\ncoupling::Bool=true: flag to compute coupling RDTs\ngeometric1::Bool=true: flag to compute geometric RDTs\ngeometric2::Bool=true: flag to compute geometric RDTs\ntuneshifts::Bool=true: flag to compute tune shifts\n\nReturns\n\nd::DrivingTerms: structure of driving terms\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.ADlinepass!-Tuple{Vector{<:AbstractElement{Float64}}, Beam{Float64}, Vector{Int64}, Vector{<:AbstractElement{Float64}}}","page":"API","title":"JuTrack.ADlinepass!","text":"ADlinepass!(line::Vector{<:AbstractElement{Float64}}, particles::Beam{Float64}, \nchanged_idx::Vector{Int}, changed_ele::Vector{<:AbstractElement{Float64}})\n\nPass particles through the line element by element. The elements in the changed_idx will be replaced by the elements in changed_ele. This is a convinent function to implement automatic differentiation that avoid directly changing parameters in line`.\n\nArguments\n\nline::Vector{<:AbstractElement{Float64}}: a vector of beam line elements\nparticles::Beam{Float64}: a beam object\nchanged_idx::Vector{Int}: a vector of indices of the elements to be changed\nchangedele::Vector{<:AbstractElement{Float64}}: a vector of elements to replace the elements in `changedidx`\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.ADlinepass_TPSA!-Union{Tuple{Max_TPS_Degree}, Tuple{TPS_Dim}, Tuple{T}, Tuple{Vector{<:AbstractElement{Float64}}, Array{CTPS{T, TPS_Dim, Max_TPS_Degree}, 1}, Vector, Vector}} where {T, TPS_Dim, Max_TPS_Degree}","page":"API","title":"JuTrack.ADlinepass_TPSA!","text":"ADlinepass_TPSA!(line::Vector{<:AbstractElement{Float64}}, rin::Vector{CTPS{T, TPS_Dim, Max_TPS_Degree}}, \nchanged_idx::Vector, changed_ele::Vector; E0::Float64=3e9, m0::Float64=m_e) where {T, TPS_Dim, Max_TPS_Degree}\n\nPass 6-D high-order TPSA coordinates through the line element by element. The elements in the changed_idx will be replaced by the elements in changed_ele. This is a convinent function to implement automatic differentiation that avoid directly changing parameters in line`.\n\nArguments\n\nline::Vector: a vector of beam line elements\nrin::Vector{CTPS{T, TPSDim, MaxTPS_Degree}}: a vector of 6-D high-order TPSA coordinates\nchanged_idx::Vector: a vector of indices of the elements to be changed\nchangedele::Vector: a vector of elements to replace the elements in `changedidx`\nE0::Float64=3e9: reference energy in eV\nm0::Float64=m_e: rest mass in eV/c^2\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.ADringpass!-Tuple{Vector, Beam{Float64}, Int64, Vector, Vector}","page":"API","title":"JuTrack.ADringpass!","text":"ADringpass!(line::Vector, particles::Beam{Float64}, nturn::Int, changed_idx::Vector, changed_ele::Vector)\n\nPass particles through the ring for nturn turns. The elements in the changed_idx will be replaced by the elements in changed_ele. This is a convinent function to implement automatic differentiation that avoid directly changing parameters in line`.\n\nArguments\n\nline::Vector: a vector of a ring\nparticles::Beam{Float64}: a beam object\nnturn::Int: number of turns\nchanged_idx::Vector: a vector of indices of the elements to be changed\nchangedele::Vector: a vector of elements to replace the elements in `changedidx`\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.ADtwissline-Tuple{EdwardsTengTwiss{Float64}, Vector{<:AbstractElement{Float64}}, Float64, Int64, Vector{Int64}, Vector{Int64}, Vector{<:AbstractElement{Float64}}}","page":"API","title":"JuTrack.ADtwissline","text":"ADtwissline(tin::EdwardsTengTwiss,seq::Vector, dp::Float64, order::Int, refpts::Vector{Int}, changed_idx::Vector, changed_ele::Vector)\n\nPropagate the Twiss parameters through a sequence of elements. Save the results at specified locations. This function is used for automatic differentiation with Enzyme to avoid access issues.\n\nArguments\n\ntin::EdwardsTengTwiss: Input Twiss parameters.\nseq::Vector: Sequence of elements.\ndp::Float64: Momentum deviation.\norder::Int: Order of the map. 0 for finite difference, others for TPSA.\nrefpts::Vector{Int}: Indices of elements where the Twiss parameters are calculated.\nchanged_idx::Vector: Indices of elements with changed parameters.\nchanged_ele::Vector: Indices of changed parameters.\n\nReturns\n\nVector{EdwardsTengTwiss}: Output Twiss parameters at specified locations.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.Baxis-Tuple{AbstractElement, AbstractVector, Float64, Float64}","page":"API","title":"JuTrack.Baxis","text":"Baxis(elem::AbstractElement, s::AbstractVector, kw::Float64, rhoinv::Float64)\n\nCompute the magnetic field on the axis of a generic wiggler.\n\nArguments\n\nelem::AbstractElement: Wiggler element\ns::AbstractVector: Position along the wiggler\nkw::Float64: Wiggler wave number (2Ï€/Lw)\nrhoinv::Float64: Inverse of magnetic rigidity scaled by Bmax\n\nReturns\n\nbx, bz: Horizontal and vertical field components (normalized by Bmax)\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.ElementRadiation-Union{Tuple{T}, Tuple{Vector{<:AbstractElement{T}}, Vector{<:EdwardsTengTwiss{T}}}} where T","page":"API","title":"JuTrack.ElementRadiation","text":"ElementRadiation(ring::Vector{<:AbstractElement{T}}, lindata::Vector{<:EdwardsTengTwiss{T}}; \n                 UseQuadrupoles::Bool=true)\n\nCompute the radiation integrals in dipoles and quadrupoles.\n\nAnalytical integration from: EVALUATION OF SYNCHROTRON RADIATION INTEGRALS R.H. Helm, M.J. Lee, P.L. Morton and M. Sands SLAC-PUB-1193, March 1973\n\nArguments\n\nring::Vector{<:AbstractElement}: Vector of lattice elements\nlindata::Vector{<:EdwardsTengTwiss}: Vector of Twiss parameters at element exits (length = length(ring))\nUseQuadrupoles::Bool=true: Include quadrupoles in radiation integrals calculation\n\nReturns\n\nI1, I2, I3, I4, I5, I6, Iv: Seven radiation integrals\n\nNote\n\nUnlike MATLAB AT, JuTrack's twissring returns Twiss parameters at element exits only. This function handles the indexing difference automatically.\n\nExample\n\ntwiss = twissring(ring, 0.0, 0)\nI1, I2, I3, I4, I5, I6, Iv = ElementRadiation(ring, twiss)\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.ElossRadiation-Union{Tuple{T}, Tuple{Vector{<:AbstractElement{T}}, Vector{<:EdwardsTengTwiss{T}}}} where T","page":"API","title":"JuTrack.ElossRadiation","text":"ElossRadiation(ring::Vector{<:AbstractElement{T}}, lindata::Vector{<:EdwardsTengTwiss{T}}) where T\n\nCompute the radiation integrals for energy loss elements.\n\nThis function handles special energy loss elements like SimpleQuantumDiffusion  or EnergyLoss that model radiation effects without actual bending magnets.\n\nArguments\n\nring::Vector{<:AbstractElement}: Vector of lattice elements\nlindata::Vector{<:EdwardsTengTwiss}: Vector of Twiss parameters at element exits\n\nReturns\n\nI1, I2, I3, I4, I5: Five radiation integrals for energy loss elements\n\nNote\n\nCurrently returns zeros as JuTrack does not yet have energy loss element types. This function is a placeholder for future implementation.\n\nExample\n\ntwiss = twissring(ring, 0.0, 0)\nI1e, I2e, I3e, I4e, I5e = ElossRadiation(ring, twiss)\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.Gauss3_Dist-Tuple{Vector{Float64}, Int64}","page":"API","title":"JuTrack.Gauss3_Dist","text":"Gauss3_Dist(distparam::Vector{Float64}, Npt::Int; seed::Int=3)\n\nGenerate 6D Gaussian distribution.\n\nArguments\n\ndistparam::Vector{Float64}: Distribution parameters of the form [sigx, sigpx, muxpx, xscale, pxscale, xmu1, xmu2, sigy, sigpy, muypy, yscale, pyscale, xmu3, xmu4, sigz, sigpz, muzpz, zscale, pzscale, xmu5, xmu6]\nNpt::Int: Number of particles\nseed::Int=3: Random seed\n\nReturn\n\nPts1::Array{Float64,2}: 6D Gaussian distribution\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.RBEND-Tuple{}","page":"API","title":"JuTrack.RBEND","text":"RBEND(;name::String = \"RBend\", len::Float64 = 0.0, angle::Float64 = 0.0, PolynomA::Array{Float64,1} = zeros(Float64, 4), \n    PolynomB::Array{Float64,1} = zeros(Float64, 4), MaxOrder::Int64=0, NumIntSteps::Int64 = 10, rad::Int64=0, \n    fint1::Float64 = 0.0, fint2::Float64 = 0.0, gap::Float64 = 0.0, FringeBendEntrance::Int64 = 1, \n    FringeBendExit::Int64 = 1, FringeQuadEntrance::Int64 = 0, FringeQuadExit::Int64 = 0, \n    FringeIntM0::Array{Float64,1} = zeros(Float64, 5), FringeIntP0::Array{Float64,1} = zeros(Float64, 5), \n    T1::Array{Float64,1} = zeros(Float64, 6), T2::Array{Float64,1} = zeros(Float64, 6), \n    R1::Array{Float64,2} = zeros(Float64, 6, 6), R2::Array{Float64,2} = zeros(Float64, 6, 6), \n    RApertures::Array{Float64,1} = zeros(Float64, 6), EApertures::Array{Float64,1} = zeros(Float64, 6), \n    KickAngle::Array{Float64,1} = zeros(Float64, 2))\n\nA rectangular bending magnet. Example:\n\nbend = RBEND(name=\"B1\", len=0.5, angle=0.5)\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.WigglerRadiation-Union{Tuple{T}, Tuple{Vector{<:AbstractElement{T}}, Vector{<:EdwardsTengTwiss{T}}}} where T","page":"API","title":"JuTrack.WigglerRadiation","text":"WigglerRadiation(ring::Vector{<:AbstractElement{T}}, lindata::Vector{<:EdwardsTengTwiss{T}}; \n                 energy::Float64=3e9, nstep::Int=60) where T\n\nCompute the radiation integrals in wigglers.\n\nWigglerRadiation computes the radiation integrals for all wigglers with the following approximations:\n\nThe self-induced dispersion is neglected in I4 and I5, but is used as a lower limit for the I5 contribution\nI1, I2 are integrated analytically\nI3 is integrated analytically for a single harmonic, numerically otherwise\n\nArguments\n\nring::Vector{<:AbstractElement}: Vector of lattice elements\nlindata::Vector{<:EdwardsTengTwiss}: Vector of Twiss parameters at element exits\nenergy::Float64=3e9: Beam energy in eV\nnstep::Int=60: Number of integration steps for numerical I3 calculation\n\nReturns\n\nI1, I2, I3, I4, I5: Five radiation integrals for wigglers\n\nNote\n\nThis function assumes wiggler elements have the following fields:\n\nLw: Wiggler period length\nBmax: Maximum magnetic field\nBy: Horizontal field harmonics (matrix where each column is [_, amplitude, _, _, harmonic, phase])\nBx: Vertical field harmonics (matrix where each column is [_, amplitude, _, _, harmonic, phase])\n\nExample\n\ntwiss = twissring(ring, 0.0, 0)\nI1, I2, I3, I4, I5 = WigglerRadiation(ring, twiss, energy=3e9)\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.computeDrivingTerms-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, JuTrack.RDTflags, Int64}","page":"API","title":"JuTrack.computeDrivingTerms","text":"computeDrivingTerms(s::Vector{Float64}, betax::Vector{Float64}, betay::Vector{Float64}, \nphix::Vector{Float64}, phiy::Vector{Float64}, etax::Vector{Float64}, Lista2L::Vector{Float64}, Listb2L::Vector{Float64}, \nListb3L::Vector{Float64}, Listb4L::Vector{Float64}, tune::Vector{Float64}, flags::RDTflags, nPeriods::Int)\n\nCompute the resonance driving terms for a given lattice.\n\nArguments\n\ns::Vector{Float64}: Vector of s positions.\nbetax::Vector{Float64}: Vector of beta functions in x.\nbetay::Vector{Float64}: Vector of beta functions in y.\nphix::Vector{Float64}: Vector of phase advances in x.\nphiy::Vector{Float64}: Vector of phase advances in y.\netax::Vector{Float64}: Vector of eta functions in x.\nLista2L::Vector{Float64}: Vector of a2L values.\nListb2L::Vector{Float64}: Vector of b2L values.\nListb3L::Vector{Float64}: Vector of b3L values.\nListb4L::Vector{Float64}: Vector of b4L values.\ntune::Vector{Float64}: Vector of tune values.\nflags::RDTflags: Flags for the driving terms calculation.\nnPeriods::Int: Number of periods in the lattice.\n\nReturns\n\nDrivingTerms: Structure containing the computed driving terms.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.computeDrivingTerms-Union{Tuple{T}, Tuple{N}, Tuple{Array{DTPSAD{N, T}, 1}, Array{DTPSAD{N, Float64}, 1}, Array{DTPSAD{N, Float64}, 1}, Array{DTPSAD{N, Float64}, 1}, Array{DTPSAD{N, Float64}, 1}, Array{DTPSAD{N, Float64}, 1}, Array{DTPSAD{N, Float64}, 1}, Array{DTPSAD{N, Float64}, 1}, Array{DTPSAD{N, Float64}, 1}, Array{DTPSAD{N, Float64}, 1}, Array{DTPSAD{N, Float64}, 1}, JuTrack.RDTflags, Int64}} where {N, T}","page":"API","title":"JuTrack.computeDrivingTerms","text":"computeDrivingTerms(s::Vector{DTPSAD{N, T}}, betax::Vector{DTPSAD{N, Float64}}, betay::Vector{DTPSAD{N, Float64}}, \nphix::Vector{DTPSAD{N, Float64}}, phiy::Vector{DTPSAD{N, Float64}}, etax::Vector{DTPSAD{N, Float64}}, Lista2L::Vector{DTPSAD{N, Float64}}, Listb2L::Vector{DTPSAD{N, Float64}}, \nListb3L::Vector{DTPSAD{N, Float64}}, Listb4L::Vector{DTPSAD{N, Float64}}, tune::Vector{DTPSAD{N, Float64}}, flags::RDTflags, nPeriods::Int)\n\nCompute the resonance driving terms for a given lattice using DTPSAD.\n\nArguments\n\nThe same as the previous function but with DTPSAD types.\n\nReturns\n\nDrivingTermsTPSAD{N}: Structure containing the computed driving terms.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.computeRDT-Tuple{Vector{<:AbstractElement{Float64}}, Vector{Int64}}","page":"API","title":"JuTrack.computeRDT","text":"computeRDT(ring::Vector{<:AbstractElement{Float64}}, index::Vector{Int}; \nchromatic=false, coupling=false, geometric1=false, geometric2=false, tuneshifts=false, E0=3e9, m0=m_e)\n\nCompute Hamiltonian resonance driving terms (RDTs)\n\nArguments\n\nring::Vector{<:AbstractElement{Float64}}: Lattice sequence\nindex::Vector{Int}: Index of the element to compute the RDTs\nchromatic::Bool: Whether to compute chromatic RDTs (default: false)\ncoupling::Bool: Whether to compute coupling RDTs (default: false)\ngeometric1::Bool: Whether to compute geometric RDTs of first order (default: false)\ngeometric2::Bool: Whether to compute geometric RDTs of second order (default: false)\ntuneshifts::Bool: Whether to compute tune shifts (default: false)\nE0::Float64: Beam energy in eV (default: 3e9)\nm0: Particle rest mass (default: m_e)\n\nReturns\n\nVector{DrivingTerms}: Vector containing the computed driving terms for each specified index\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.computeRDT-Union{Tuple{T}, Tuple{N}, Tuple{Vector{<:AbstractElement{DTPSAD{N, T}}}, Vector{Int64}}} where {N, T}","page":"API","title":"JuTrack.computeRDT","text":"computeRDT(ring::Vector{<:AbstractElement{DTPSAD{N, T}}}, index::Vector{Int}; \nchromatic=false, coupling=false, geometric1=false, geometric2=false, tuneshifts=false, E0=3e9, m0=m_e) where {N, T}\n\nCompute Hamiltonian resonance driving terms (RDTs)\n\nArguments\n\nring::Vector{<:AbstractElement{DTPSAD{N, T}}}: Lattice sequence\nindex::Vector{Int}: Index of the element to compute the RDTs\nchromatic::Bool: Whether to compute chromatic RDTs (default: false)\ncoupling::Bool: Whether to compute coupling RDTs (default: false)\ngeometric1::Bool: Whether to compute geometric RDTs of first order (default: false)\ngeometric2::Bool: Whether to compute geometric RDTs of second order (default: false)\ntuneshifts::Bool: Whether to compute tune shifts (default: false)\nE0::Float64: Beam energy in eV (default: 3e9)\nm0: Particle rest mass (default: m_e)\n\nReturns\n\nVector{DrivingTermsTPSAD{NVAR()}}: Vector containing the computed driving terms for each specified index\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.dynamic_aperture-Tuple{Vector{<:AbstractElement{Float64}}, Int64, Float64, Float64, Int64, Float64, Float64}","page":"API","title":"JuTrack.dynamic_aperture","text":"dynamic_aperture(RING, nturns, amp_max, amp_step, angle_steps, E, dp)\n\nCalculate the dynamic aperture of a given lattice.\n\nArguments\n\nRING::Vector{<:AbstractElement{Float64}}: a ring lattice\nnturns::Int: number of turns to track\namp_max::Float64: maximum amplitude [m]\namp_step::Float64: step size of amplitude scan [m]\nangle_steps::Int: number of lines. 11, 13, 19, 21, 37 etc.\nE::Float64: beam energy [eV]\ndp::Float64: momentum spread\n\nReturns\n\nDA::Array{Float64,2}: boundary points of dynamic aperture\nsurvived_particles::Array{Float64,2}: survived particles in x and y [m]\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.elrad-Union{Tuple{T}, Tuple{AbstractElement{T}, EdwardsTengTwiss{T}, EdwardsTengTwiss{T}}} where T","page":"API","title":"JuTrack.elrad","text":"elrad(elem::AbstractElement{T}, dini::EdwardsTengTwiss{T}, dend::EdwardsTengTwiss{T}) where T\n\nCompute radiation integrals for a single element.\n\nArguments\n\nelem::AbstractElement: Lattice element\ndini::EdwardsTengTwiss: Twiss parameters at element entrance\ndend::EdwardsTengTwiss: Twiss parameters at element exit\n\nReturns\n\nTuple of (di1, di2, di3, di4, di5, di6, div): Radiation integral contributions\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.fastfindm66","page":"API","title":"JuTrack.fastfindm66","text":"fastfindm66(LATTICE::Vector{<:AbstractElement{Float64}}, dp=0.0; E0::Float64=3e9, m0::Float64=m_e, orb::Vector{Float64}=zeros(6))\n\nFind the 6x6 transfer matrix of a lattice using numerical differentiation.\n\nArguments\n\nLATTICE: Beam line sequence.\ndp::Float64=0.0: Momentum deviation.\nE0::Float64=3e9: Reference energy in eV.\nm0::Float64=m_e: Particle mass.\norb::Vector{Float64}=zeros(6): Initial orbit.\n\nReturns\n\nM66: 6x6 transfer matrix.\n\n\n\n\n\n","category":"function"},{"location":"api/#JuTrack.fastfindm66-Union{Tuple{Vector{<:AbstractElement{DTPSAD{N, T}}}}, Tuple{T}, Tuple{N}, Tuple{Vector{<:AbstractElement{DTPSAD{N, T}}}, Float64}} where {N, T}","page":"API","title":"JuTrack.fastfindm66","text":"fastfindm66(LATTICE::Vector{<:AbstractElement{DTPSAD{N, T}}}, dp::Float64=0.0; \nE0::Float64=3e9, m0::Float64=m_e, orb::Vector{DTPSAD{N, T}}=zeros(6)) where {N, T}\n\nFind the 6x6 transfer matrix of a lattice using numerical differentiation for DTPSAD elements.\n\nArguments\n\nLATTICE: Beam line sequence.\ndp::Float64=0.0: Momentum deviation.\nE0::Float64=3e9: Reference energy in eV.\nm0::Float64=m_e: Particle mass.\norb::Vector{DTPSAD{N, T}}=zeros(6): Initial orbit.\n\nReturns\n\nM66: 6x6 transfer matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.fastfindm66_refpts-Tuple{Vector{<:AbstractElement{Float64}}, Float64, Vector{Int64}}","page":"API","title":"JuTrack.fastfindm66_refpts","text":"fastfindm66_refpts(LATTICE::Vector{<:AbstractElement{Float64}}, dp::Float64, refpts::Vector{Int}; \nE0::Float64=3e9, m0::Float64=m_e, orb::Vector{Float64}=zeros(6))\n\nFind the 6x6 transfer matrix at specified reference points using numerical differentiation.\n\nArguments\n\nLATTICE: Beam line sequence.\ndp::Float64: Momentum deviation.\nrefpts::Vector{Int}: Indices of reference points.\nE0::Float64=3e9: Reference energy in eV.\nm0::Float64=m_e: Particle mass.\norb::Vector{Float64}=zeros(6): Initial orbit.\n\nReturns\n\nM66_refpts: 6x6 transfer matrices at each reference point.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.fastfindm66_refpts-Union{Tuple{T}, Tuple{N}, Tuple{Vector{<:AbstractElement{DTPSAD{N, T}}}, Float64, Vector{Int64}}} where {N, T}","page":"API","title":"JuTrack.fastfindm66_refpts","text":"fastfindm66_refpts(LATTICE::Vector{<:AbstractElement{DTPSAD{N, T}}}, dp::Float64, refpts::Vector{Int}; \nE0::Float64=3e9, m0::Float64=m_e, orb::Vector{Float64}=zeros(6)) where {N, T}\n\nFind the 6x6 transfer matrix at specified reference points using numerical differentiation for DTPSAD elements.\n\nArguments\n\nLATTICE: Beam line sequence.\ndp::Float64: Momentum deviation.\nrefpts::Vector{Int}: Indices of reference points.\nE0::Float64=3e9: Reference energy in eV.\nm0::Float64=m_e: Particle mass.\norb::Vector{Float64}=zeros(6): Initial orbit.\n\nReturns\n\nM66_refpts: 6x6 transfer matrices at each reference point.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.find_closed_orbit","page":"API","title":"JuTrack.find_closed_orbit","text":"find_closed_orbit(line::Vector{AbstractElement{Float64}}, dp::Float64=0.0; mass::Float64=m_e, energy::Float64=1e9,\nguess::Vector{Float64}=zeros(Float64, 6), max_iter::Int=20, tol::Float64=1e-8)\n\nCalculates the closed orbit for a given lattice using Newton's method.\n\nArguments\n\nline::Vector{AbstractElement{Float64}}: The lattice represented as a vector of elements.\ndp::Float64=0.0: Relative momentum deviation.\nmass::Float64=m_e: Mass of the particle.\nenergy::Float64=1e9: Energy of the particle in eV.\nguess::Vector{Float64}=zeros(Float64, 6): Initial guess for the closed orbit.\nmax_iter::Int=20: Maximum number of iterations.\ntol::Float64=1e-8: Tolerance for convergence.\n\nReturns\n\nx_closed::Vector{Float64}: The closed orbit coordinates.\nM::Matrix{Float64}: The one-turn transfer matrix at the closed orbit\n\n\n\n\n\n","category":"function"},{"location":"api/#JuTrack.find_closed_orbit-Union{Tuple{Array{AbstractElement{DTPSAD{N, T}}, 1}}, Tuple{T}, Tuple{N}, Tuple{Array{AbstractElement{DTPSAD{N, T}}, 1}, Float64}} where {N, T}","page":"API","title":"JuTrack.find_closed_orbit","text":"find_closed_orbit(line::Vector{AbstractElement{DTPSAD{N, T}}}, dp::Float64=0.0; mass::Float64=m_e, energy::Float64=1e9,\nguess::Vector{DTPSAD{N, T}}=zeros(DTPSAD{N, T}, 6), max_iter::Int=20, tol::Float64=1e-8) where {N, T <: Number}\n\nCalculates the closed orbit for a given lattice using Newton's method in TPSA (DTPSAD type) format.\n\nArguments\n\nline::Vector{AbstractElement{DTPSAD{N, T}}}: The lattice represented as a vector of elements.\ndp::Float64=0.0: Relative momentum deviation.\nmass::Float64=m_e: Mass of the particle.\nenergy::Float64=1e9: Energy of the particle in eV.\nguess::Vector{DTPSAD{N, T}}=zeros(DTPSAD{N, T}, 6): Initial guess for the closed orbit.\nmax_iter::Int=20: Maximum number of iterations.\ntol::Float64=1e-8: Tolerance for convergence.\n\nReturns\n\nx_closed::Vector{DTPSAD{N, T}}: The closed orbit\nM::Matrix{DTPSAD{N, T}}: The one-turn transfer matrix at the closed orbit\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.find_closed_orbit_4d-Tuple{Vector}","page":"API","title":"JuTrack.find_closed_orbit_4d","text":"find_closed_orbit_4d(ring::Vector; dp::Float64=0.0, x0=zeros(4), energy::Float64=3.5e9, mass::Float64=m_e,\ntol::Float64=1e-8, maxiter::Int=20)\n\nFind the 4-D closed orbit of a ring using autodiff. !!! Don't use this function for automatic differentiation because it already uses AD.  !!! Use this function for AD will result in second order differentiation (slow or crash).\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.find_closed_orbit_6d-Tuple{Vector}","page":"API","title":"JuTrack.find_closed_orbit_6d","text":"find_closed_orbit_6d(ring::Vector; x0=zeros(6), energy::Float64=3.5e9, mass::Float64=m_e,\ntol::Float64=1e-8, maxiter::Int=20)\n\nFind the 6-D closed orbit of a ring using autodiff. To find a 6-D closed orbit, the ring must have active RF cavities. !!! Don't use this function for automatic differentiation because it already uses AD.  !!! Use this function for AD will result in second order differentiation (slow or crash).\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.findelem-Tuple{Vector, Symbol, Any}","page":"API","title":"JuTrack.findelem","text":"findelem(ring::Vector, field::Symbol, value)\n\nFind the index of elements with the specified field value in the ring.\n\nArguments\n\nring::Vector: a vector of beam line elements\nfield::Symbol: the field name\nvalue: the value of the field\n\nReturn\n\nele_index::Vector{Int}: a vector of indices of the elements with the specified field value\n\nExample\n\nele_index = findelem(ring, :name, \"QF\")\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.findelem-Tuple{Vector, Type}","page":"API","title":"JuTrack.findelem","text":"findelem(ring::Vector, type::Type)\n\nFind the index of elements with the specified type in the ring.\n\nArguments\n\nring::Vector: a vector of beam line elements\ntype::Type: the type of the element\n\nReturn\n\nele_index::Vector{Int}: a vector of indices of the elements with the specified type\n\nExample\n\nele_index = findelem(ring, DRIFT)\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.findm66-Tuple{Vector{<:AbstractElement{Float64}}, Float64, Int64}","page":"API","title":"JuTrack.findm66","text":"findm66(seq::Vector{<:AbstractElement{Float64}}, dp::Float64, order::Int; E0::Float64=3e9, m0::Float64=m_e, orb::Vector{Float64}=zeros(6))\n\nFind the 6x6 transfer matrix.\n\nArguments\n\nseq::Vector{<:AbstractElement{Float64}}: Sequence of elements.\ndp::Float64: Relative momentum deviation.\norder::Int: Order of the TPSA. If order == 0, a fast numerical method is used.\nE0::Float64=3e9: Reference energy in eV.\nm0::Float64=m_e: Particle mass.\norb::Vector{Float64}=zeros(6): Initial orbit.\t\t\n\nReturns\n\nMatrix{Float64}: 6x6 transfer matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.findm66-Union{Tuple{T}, Tuple{N}, Tuple{Vector{<:AbstractElement{DTPSAD{N, T}}}, Float64, Int64}} where {N, T}","page":"API","title":"JuTrack.findm66","text":"findm66(seq::Vector{<:AbstractElement{DTPSAD{N, T}}}, dp::Float64, order::Int; E0::Float64=3e9, m0::Float64=m_e, orb::Vector{Float64}=zeros(6)) where {N, T}\n\nFind the 6x6 transfer matrix for a DTPSAD lattice.\n\nArguments\n\nseq::Vector{<:AbstractElement{DTPSAD{N, T}}}: Sequence of elements.\ndp::Float64: Relative momentum deviation.\norder::Int: Only order == 0 is supported.\nE0::Float64=3e9: Reference energy in eV.\nm0::Float64=m_e: Particle mass.\norb::Vector{Float64}=zeros(6): Initial orbit.\n\nReturns\n\nMatrix{Float64}: 6x6 transfer matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.findm66_refpts-Tuple{Vector{<:AbstractElement{Float64}}, Float64, Int64, Vector{Int64}}","page":"API","title":"JuTrack.findm66_refpts","text":"findm66_refpts(seq::Vector{<:AbstractElement{Float64}}, dp::Float64, order::Int, refpts::Vector{Int}; \nE0::Float64=3e9, m0::Float64=m_e, orb::Vector{Float64}=zeros(6))\n\nFind the 6x6 transfer matrix at specified reference points using high-order TPSA.\n\nArguments\n\nseq::Vector{<:AbstractElement{Float64}}: Sequence of elements.\ndp::Float64: Relative momentum deviation.\norder::Int: Order of the TPSA. \nrefpts::Vector{Int}: Indices of reference points.\nE0::Float64=3e9: Reference energy in eV.\nm0::Float64=m_e: Particle mass.\norb::Vector{Float64}=zeros(6): Initial orbit.\t\t\n\nReturns\n\nMat_list::Array{Float64,3}: 6x6 transfer matrices at each reference point.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.get_2nd_moment!-Tuple{Beam}","page":"API","title":"JuTrack.get_2nd_moment!","text":"get_2nd_moment!(beam::Beam)\n\nGet 2nd moment of the beam. Example:\n\nget_2nd_moment!(beam)\nprintln(beam.moment2nd)\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.get_centroid!-Tuple{Beam}","page":"API","title":"JuTrack.get_centroid!","text":"get_centroid!(beam::Beam)\n\nGet 6-D centroid of the beam. Example:\n\nget_centroid!(beam)\nprintln(beam.centroid)\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.get_emittance!-Tuple{Beam}","page":"API","title":"JuTrack.get_emittance!","text":"get_emittance!(beam::Beam)\n\nGet emittance of the beam. Example:\n\nget_emittance!(beam)\nprintln(beam.emittance)\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.getfoc-Union{Tuple{AbstractElement{T}}, Tuple{T}} where T","page":"API","title":"JuTrack.getfoc","text":"getfoc(elem::AbstractElement{T}) where T\n\nGet the focusing strength (K value) from an element.\n\nArguments\n\nelem::AbstractElement: Lattice element\n\nReturns\n\nK::Float64: Quadrupole focusing strength (K = âˆ‚Â²By/âˆ‚xÂ²)\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.histogram1DinZ!-Tuple{Beam, Int64, Any, Any, Any}","page":"API","title":"JuTrack.histogram1DinZ!","text":"histogram1DinZ!(beam::Beam, nbins::Int64, inzindex, zhist, zhist_edges)\n\nHistogram in z.\n\nExample:\n\nhistogram1DinZ!(beam, beam.znbin, beam.inzindex, beam.zhist, beam.zhist_edges)\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.histogram1DinZ!-Tuple{Beam}","page":"API","title":"JuTrack.histogram1DinZ!","text":"histogram1DinZ!(beam::Beam)\n\nHistogram in z.\n\nExample:\n\nhistogram1DinZ!(beam)\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.initilize_6DGaussiandist!-Tuple{Beam, AbstractOptics4D, JuTrack.AbstractLongitudinalMap}","page":"API","title":"JuTrack.initilize_6DGaussiandist!","text":"initilize_6DGaussiandist!(beam::Beam, optics::AbstractOptics4D, lmap::AbstractLongitudinalMap)\n\nInitialize 6D Gaussian distribution for the beam. Example:\n\ninitilize_6DGaussiandist!(beam, optics, lmap)\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.linepass!-Tuple{Vector{<:AbstractElement{Float64}}, Beam{Float64}, Vector{Int64}}","page":"API","title":"JuTrack.linepass!","text":"linepass!(line::Vector{<:AbstractElement{Float64}}, particles::Beam{Float64}, refpts::Vector{Int})\n\nPass particles through the line element by element. Save the particles at the reference points.\n\nArguments\n\nline::Vector{<:AbstractElement{Float64}}: a vector of beam line elements\nparticles::Beam{Float64}: a beam object\nrefpts::Vector{Int}: a vector of reference points\n\nReturns\n\nsaved_particles::Vector: a vector of saved particles at the reference points\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.linepass!-Tuple{Vector{<:AbstractElement{Float64}}, Beam{Float64}}","page":"API","title":"JuTrack.linepass!","text":"linepass!(line::Vector{<:AbstractElement{Float64}}, particles::Beam{Float64})\n\nPass the beam through the line element by element.\n\nArguments\n\nline::Vector{<:AbstractElement{Float64}}: a vector of beam line elements\nparticles::Beam{Float64}: a beam object\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.linepass_TPSA!-Union{Tuple{Max_TPS_Degree}, Tuple{TPS_Dim}, Tuple{T}, Tuple{Vector{<:AbstractElement{Float64}}, Array{CTPS{T, TPS_Dim, Max_TPS_Degree}, 1}}} where {T, TPS_Dim, Max_TPS_Degree}","page":"API","title":"JuTrack.linepass_TPSA!","text":"linepass_TPSA!(line::Vector{<:AbstractElement{Float64}}, rin::Vector{CTPS{T, TPS_Dim, Max_TPS_Degree}};\nE0::Float64=3e9, m0::Float64=m_e) where {T, TPS_Dim, Max_TPS_Degree}\n\nPass 6-D high-order TPSA coordinates through the line element by element.\n\nArguments\n\nline::Vector{<:AbstractElement{Float64}}: a vector of beam line elements\nrin::Vector{CTPS{T, TPSDim, MaxTPS_Degree}}: a vector of 6-D high-order TPSA coordinates\nE0::Float64=3e9: reference energy in eV\nm0::Float64=m_e: rest mass in eV/c^2\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.lu_decomposition-Tuple{AbstractMatrix}","page":"API","title":"JuTrack.lu_decomposition","text":"lu_decomposition(A)\n\nPerforms an in-place LU decomposition of a square matrix A.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.lu_solve-Tuple{AbstractMatrix, AbstractVector}","page":"API","title":"JuTrack.lu_solve","text":"lu_solve(LU, b)\n\nSolves the system Ax = b given the LU decomposition of A.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.pass!-Tuple{DRIFT, Vector{Float64}, Int64, Beam{Float64}}","page":"API","title":"JuTrack.pass!","text":"pass!(ele::DRIFT, r_in::Array{Float64,1}, num_particles::Int64, particles::Beam{Float64})\n\nThis is a function to track particles through a drift element.\n\nArguments\n\nele::DRIFT: a drift element\nrin::Array{Float64,1}: 6-by-numparticles array\nnum_particles::Int64: number of particles\nparticles::Beam{Float64}: beam object\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.periodicEdwardsTengTwiss-Tuple{Vector{<:AbstractElement{Float64}}, Float64, Int64}","page":"API","title":"JuTrack.periodicEdwardsTengTwiss","text":"periodicEdwardsTengTwiss(seq::Vector{<:AbstractElement{Float64}}, dp::Float64, order::Int)\n\nCalculate the Twiss parameters for a periodic lattice.\n\nArguments\n\nseq::Vector{<:AbstractElement{Float64}}: Sequence of elements.\ndp::Float64: Momentum deviation.\norder::Int: Order of the map. 0 for finite difference, others for TPSA.\n\nReturns\n\nEdwardsTengTwiss: Output Twiss parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.periodicEdwardsTengTwiss-Union{Tuple{T}, Tuple{N}, Tuple{Vector{<:AbstractElement{DTPSAD{N, T}}}, Float64, Int64}} where {N, T}","page":"API","title":"JuTrack.periodicEdwardsTengTwiss","text":"periodicEdwardsTengTwiss(seq::Vector{<:AbstractElement{DTPSAD{N, T}}}, dp::Float64, order::Int) where {N, T}\n\nCalculate the Twiss parameters for a periodic lattice with DTPSAD elements.\n\nArguments\n\nseq::Vector{<:AbstractElement{DTPSAD{N, T}}}: Sequence of elements.\ndp::Float64: Momentum deviation.\norder::Int: Order of the map. Only 0 is supported for DTPSAD elements.\n\nReturns\n\nEdwardsTengTwiss: Output Twiss parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.plinepass!-Tuple{Vector{<:AbstractElement{Float64}}, Beam{Float64}}","page":"API","title":"JuTrack.plinepass!","text":"plinepass!(line::Vector{<:AbstractElement{Float64}}, particles::Beam{Float64})\n\nPass particles through the line element by element by implementing multi-threading.  The number of threads is determined by the environment variable JULIA_NUM_THREADS.\n\nArguments\n\nline::Vector{<:AbstractElement{Float64}}: a vector of beam line elements\nparticles::Beam{Float64}: a beam object\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.pringpass!-Tuple{Vector{<:AbstractElement{Float64}}, Beam{Float64}, Int64}","page":"API","title":"JuTrack.pringpass!","text":"pringpass!(line::Vector{<:AbstractElement{Float64}}, particles::Beam{Float64}, nturn::Int)\n\nPass particles through the ring by implementing multi-threading.  The number of threads is determined by the environment variable JULIA_NUM_THREADS.\n\nArguments\n\nline::Vector{<:AbstractElement{Float64}}: a vector of beam line elements\nparticles::Beam{Float64}: a beam object\nnturn::Int: number of turns\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.ringpara-Tuple{Vector{<:AbstractElement}}","page":"API","title":"JuTrack.ringpara","text":"ringpara(ring::Vector{<:AbstractElement}; \n         energy::Float64=3e9, \n         Vrf::Float64=0.0,\n         harm::Int=1,\n         freq_rf::Float64=0.0,\n         dp::Float64=0.0,\n         print_summary::Bool=true)\n\nCalculate and optionally print ring parameters including equilibrium emittance, damping times,  energy spread, and RF-dependent parameters.\n\nThis function computes radiation integrals from dipoles, quadrupoles, and wigglers, then  calculates equilibrium beam parameters based on synchrotron radiation theory.\n\nArguments\n\nring::Vector{<:AbstractElement}: Vector of lattice elements\nenergy::Float64=3e9: Beam energy in eV\nVrf::Float64=0.0: RF voltage per cell [V]\nharm::Int=1: Harmonic number\nfreq_rf::Float64=0.0: RF frequency in Hz\ndp::Float64=0.0: Momentum deviation (for off-momentum calculations)\nprint_summary::Bool=true: If true, print parameter summary\n\nReturns\n\nNamedTuple with all calculated parameters\n\nExample\n\nusing JuTrack\ninclude(\"src/demo/SPEAR3/spear3.jl\")\nring = spear3()\n\n# Print summary\nringpara(ring, energy=3e9, Vrf=3.2e6, harm=372, freq_rf=476e6)\n\n# Get parameters as structure\nparams = ringpara(ring, energy=3e9, Vrf=3e6, harm=372, freq_rf=476e6, print_summary=false)\nprintln(\"Natural emittance: \", params.emittx * 1e9, \" nmâ‹…rad\")\n\nReference\n\nBased on AT's ringpara function. See also:\n\nH. Wiedemann, \"Particle Accelerator Physics\"\nM. Sands, \"The Physics of Electron Storage Rings\"\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.ringpass!-Tuple{Vector{<:AbstractElement{Float64}}, Beam{Float64}, Int64, Bool}","page":"API","title":"JuTrack.ringpass!","text":"ringpass!(line::Vector{<:AbstractElement{Float64}}, particles::Beam{Float64}, nturn::Int, save::Bool)\n\nPass particles through the ring for nturn turns. Save the particles at each turn.\n\nArguments\n\nline::Vector{<:AbstractElement{Float64}}: a vector of beam line elements\nparticles::Beam{Float64}: a beam object\nnturn::Int: number of turns\nsave::Bool: Flag\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.ringpass!-Tuple{Vector{<:AbstractElement{Float64}}, Beam{Float64}, Int64}","page":"API","title":"JuTrack.ringpass!","text":"ringpass!(line::Vector{<:AbstractElement{Float64}}, particles::Beam{Float64}, nturn::Int)\n\nPass particles through the ring for nturn turns.\n\nArguments\n\nline::Vector{<:AbstractElement{Float64}}: a vector of beam line elements\nparticles::Beam{Float64}: a beam object\nnturn::Int: number of turns\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.ringpass_TPSA!-Union{Tuple{Max_TPS_Degree}, Tuple{TPS_Dim}, Tuple{T}, Tuple{Vector{<:AbstractElement{Float64}}, Array{CTPS{T, TPS_Dim, Max_TPS_Degree}, 1}, Int64}} where {T, TPS_Dim, Max_TPS_Degree}","page":"API","title":"JuTrack.ringpass_TPSA!","text":"ringpass_TPSA!(line::Vector{<:AbstractElement{Float64}}, rin::Vector{CTPS{T, TPS_Dim, Max_TPS_Degree}}, nturn::Int;\nE0::Float64=3e9, m0::Float64=m_e) where {T, TPS_Dim, Max_TPS_Degree}\n\nPass 6-D high-order TPSA coordinates through the ring for nturn turns.\n\nArguments\n\nline::Vector: a vector of beam line elements\nrin::Vector{CTPS{T, TPSDim, MaxTPS_Degree}}: a vector of 6-D high-order TPSA coordinates\nnturn::Int: number of turns\nE0::Float64=3e9: reference energy in eV\nm0::Float64=m_e: rest mass in eV/c^2\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.spos-Tuple{Vector{AbstractElement{Float64}}, Vector{Int64}}","page":"API","title":"JuTrack.spos","text":"spos(ring::Vector, idx::Vector)\n\nCalculate the s position of the specified elements in the lattice.\n\nArguments\n\nring::Vector: a vector of beam line elements\nidx::Vector: a vector of indices of the elements\n\nReturn\n\npos::Vector{Float64}: a vector of s positions of the specified elements\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.spos-Tuple{Vector{AbstractElement{Float64}}}","page":"API","title":"JuTrack.spos","text":"spos(ring::Vector)\n\nCalculate the s position of each element in the lattice.\n\nArguments\n\nring::Vector: a vector of beam line elements\n\nReturn\n\npos::Vector{Float64}: a vector of s positions\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.symplectic_conjugate_2by2-Union{Tuple{Matrix{T}}, Tuple{T}} where T","page":"API","title":"JuTrack.symplectic_conjugate_2by2","text":"symplectic_conjugate_2by2(M::Matrix{T}) where T\n\nCompute the symplectic conjugate of a 2x2 matrix M.\n\nArguments\n\nM::Matrix{T}: The input 2x2 matrix.\n\nReturns\n\nMatrix{T}: The symplectic conjugate of the input matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.total_length-Tuple{Vector}","page":"API","title":"JuTrack.total_length","text":"total_length(ring::Vector)\n\nCalculate the total length of the lattice.\n\nArguments\n\nring::Vector: a vector of beam line elements\n\nReturn\n\nleng::Float64: total length of the lattice\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.trapz-Tuple{AbstractVector, AbstractVector}","page":"API","title":"JuTrack.trapz","text":"trapz(x::AbstractVector, y::AbstractVector)\n\nTrapezoidal numerical integration.\n\nArguments\n\nx::AbstractVector: Independent variable (must be sorted)\ny::AbstractVector: Dependent variable\n\nReturns\n\nIntegral of y with respect to x using trapezoidal rule\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.twissPropagate-Tuple{EdwardsTengTwiss{Float64}, Matrix{Float64}}","page":"API","title":"JuTrack.twissPropagate","text":"twissPropagate(tin::EdwardsTengTwiss{Float64},M::Matrix{Float64})\n\nPropagate the Twiss parameters through a matrix M.\n\nArguments\n\ntin::EdwardsTengTwiss{Float64}: Input Twiss parameters.\nM::Matrix{Float64}: Transfer matrix.\n\nReturns\n\nEdwardsTengTwiss{Float64}: Output Twiss parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.twissPropagate-Union{Tuple{T}, Tuple{N}, Tuple{EdwardsTengTwiss{DTPSAD{N, T}}, Array{DTPSAD{N, T}, 2}}} where {N, T}","page":"API","title":"JuTrack.twissPropagate","text":"twissPropagate(tin::EdwardsTengTwiss{DTPSAD{N,T}},M::Matrix{DTPSAD{N,T}}) where {N,T}\n\nPropagate the Twiss parameters through a matrix M in TPSA (DTPSAD type) format.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.twiss_beam-Tuple{Beam}","page":"API","title":"JuTrack.twiss_beam","text":"twiss_beam(beam::Beam)\n\nCalculate twiss parameters of the beam.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.twissline-Tuple{EdwardsTengTwiss{Float64}, Vector{<:AbstractElement{Float64}}, Float64, Int64, Int64}","page":"API","title":"JuTrack.twissline","text":"twissline(tin::EdwardsTengTwiss{Float64},seq::Vector{<:AbstractElement{Float64}}, dp::Float64, order::Int, endindex::Int)\n\nPropagate the Twiss parameters through a sequence of elements up to a specified index.\n\nArguments\n\ntin::EdwardsTengTwiss: Input Twiss parameters.\nseq::Vector: Sequence of elements.\ndp::Float64: Momentum deviation.\norder::Int: Order of the map. 0 for finite difference, others for TPSA.\nendindex::Int: Index of the last element in the sequence.\n\nReturns\n\nEdwardsTengTwiss: Output Twiss parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.twissline-Tuple{EdwardsTengTwiss{Float64}, Vector{<:AbstractElement{Float64}}, Float64, Int64, Vector{Int64}}","page":"API","title":"JuTrack.twissline","text":"twissline(tin::EdwardsTengTwiss{Float64},seq::Vector{<:AbstractElement{Float64}}, dp::Float64, order::Int, refpts::Vector{Int})\n\nPropagate the Twiss parameters through a sequence of elements. Save the results at specified locations.\n\nArguments\n\ntin::EdwardsTengTwiss: Input Twiss parameters.\nseq::Vector: Sequence of elements.\ndp::Float64: Momentum deviation.\norder::Int: Order of the map. 0 for finite difference, others for TPSA.\nrefpts::Vector{Int}: Indices of elements where the Twiss parameters are calculated.\n\nReturns\n\nVector{EdwardsTengTwiss}: Output Twiss parameters at specified locations.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.twissline-Union{Tuple{T}, Tuple{N}, Tuple{EdwardsTengTwiss{DTPSAD{N, T}}, Vector{<:AbstractElement{DTPSAD{N, T}}}, Float64, Int64, Int64}} where {N, T}","page":"API","title":"JuTrack.twissline","text":"twissline(tin::EdwardsTengTwiss{DTPSAD{N,T}},seq::Vector{<:AbstractElement{DTPSAD{N, T}}}, dp::Float64, order::Int, endindex::Int) where {N, T}\n\nPropagate the Twiss parameters through a sequence of DTPSAD elements up to a specified index\n\nArguments\n\ntin::EdwardsTengTwiss: Input Twiss parameters.\nseq::Vector: Sequence of elements.\ndp::Float64: Momentum deviation.\norder::Int: Order of the map. Only 0 is supported for DTPSAD elements.\nendindex::Int: Index of the last element in the sequence.\n\nReturns\n\nEdwardsTengTwiss: Output Twiss parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.twissline-Union{Tuple{T}, Tuple{N}, Tuple{EdwardsTengTwiss{DTPSAD{N, T}}, Vector{<:AbstractElement{DTPSAD{N, T}}}, Float64, Int64, Vector{Int64}}} where {N, T}","page":"API","title":"JuTrack.twissline","text":"twissline(tin::EdwardsTengTwiss{DTPSAD{N,T}},seq::Vector{<:AbstractElement{DTPSAD{N, T}}}, dp::Float64, order::Int, refpts::Vector{Int}) where {N, T}\n\nPropagate the Twiss parameters through a sequence of DTPSAD elements up to a specified index\n\nArguments\n\ntin::EdwardsTengTwiss: Input Twiss parameters.\nseq::Vector: Sequence of elements.\ndp::Float64: Momentum deviation.\norder::Int: Order of the map. Only 0 is supported for DTPSAD elements.\nrefpts::Vector{Int}: Indices of elements where the Twiss parameters are calculated.\n\nReturns\n\nEdwardsTengTwiss: Output Twiss parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.twissring-Tuple{Vector{<:AbstractElement{Float64}}, Float64, Int64, Vector{Int64}}","page":"API","title":"JuTrack.twissring","text":"twissring(seq::Vector{<:AbstractElement{Float64}}, dp::Float64, order::Int, refpts::Vector{Int};\nE0::Float64=3e9, m0::Float64=m_e)\n\nCalculate the periodic Twiss parameters along the ring at specified reference points.\n\nArguments\n\nseq::Vector: Sequence of elements.\ndp::Float64: Momentum deviation.\norder::Int: Order of the map. 0 for finite difference, others for TPSA.\nrefpts::Vector{Int}: Reference points along the ring.\nE0::Float64: Beam energy in eV. Default is 3 GeV.\nm0::Float64: Particle rest mass in eV/cÂ². Default is electron mass.\n\nReturns\n\ntwis: Twiss parameters along the ring.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.twissring-Tuple{Vector{<:AbstractElement{Float64}}, Float64, Int64}","page":"API","title":"JuTrack.twissring","text":"twissring(seq::Vector{<:AbstractElement{Float64}}, dp::Float64, order::Int;\nE0::Float64=3e9, m0::Float64=m_e)\n\nCalculate the periodic Twiss parameters along the ring.\n\nArguments\n\nseq::Vector: Sequence of elements.\ndp::Float64: Momentum deviation.\norder::Int: Order of the map. 0 for finite difference, others for TPSA.\nE0::Float64: Beam energy in eV. Default is 3 GeV.\nm0::Float64: Particle rest mass in eV/cÂ². Default is electron mass.\n\nReturns\n\ntwis: Twiss parameters along the ring.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.twissring-Union{Tuple{T}, Tuple{N}, Tuple{Vector{<:AbstractElement{DTPSAD{N, T}}}, Float64, Int64, Vector{Int64}}} where {N, T}","page":"API","title":"JuTrack.twissring","text":"twissring(seq::Vector{<:AbstractElement{DTPSAD{N, T}}}, dp::Float64, order::Int, refpts::Vector{Int};\nE0::Float64=3e9, m0::Float64=m_e) where {N, T}\n\nCalculate the periodic Twiss parameters along the ring with DTPSAD elements at specified reference points.\n\nArguments\n\nseq::Vector: Sequence of elements.\ndp::Float64: Momentum deviation.\norder::Int: Order of the map. 0 for finite difference, others for TPSA.\nrefpts::Vector{Int}: Reference points along the ring.\nE0::Float64: Beam energy in eV. Default is 3 GeV.\nm0::Float64: Particle rest mass in eV/cÂ². Default is electron mass.\n\nReturns\n\ntwis: Twiss parameters along the ring.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.twissring-Union{Tuple{T}, Tuple{N}, Tuple{Vector{<:AbstractElement{DTPSAD{N, T}}}, Float64, Int64}} where {N, T}","page":"API","title":"JuTrack.twissring","text":"twissring(seq::Vector{<:AbstractElement{DTPSAD{N, T}}}, dp::Float64, order::Int;\nE0::Float64=3e9, m0::Float64=m_e) where {N, T}\n\nCalculate the periodic Twiss parameters along the ring with DTPSAD elements.\n\nArguments\n\nseq::Vector: Sequence of elements.\ndp::Float64: Momentum deviation.\norder::Int: Order of the map. 0 for finite difference, others for TPSA.\nE0::Float64: Beam energy in eV. Default is 3 GeV.\nm0::Float64: Particle rest mass in eV/cÂ². Default is electron mass.\n\nReturns\n\ntwis: Twiss parameters along the ring.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuTrack.wigrad-Tuple{AbstractElement, EdwardsTengTwiss, Float64, Int64}","page":"API","title":"JuTrack.wigrad","text":"wigrad(elem::AbstractElement, dini::EdwardsTengTwiss, Brho::Float64, nstep::Int)\n\nCompute radiation integrals for a single wiggler element.\n\nArguments\n\nelem::AbstractElement: Wiggler element\ndini::EdwardsTengTwiss: Twiss parameters at wiggler entrance\nBrho::Float64: Magnetic rigidity (Tâ‹…m)\nnstep::Int: Number of integration steps\n\nReturns\n\nTuple of (di1, di2, di3, di4, di5): Radiation integral contributions\n\n\n\n\n\n","category":"method"},{"location":"#JuTrack","page":"Home","title":"JuTrack","text":"A Julia-based package that enables advanced auto differentiation (AD) for symplectic 6-D particle tracking in particle accelerators. A mannual can be found at docs.","category":"section"},{"location":"#Citation","page":"Home","title":"Citation","text":"@article{WAN2025109497,\ntitle = {JuTrack: A Julia package for auto-differentiable accelerator modeling and particle tracking},\njournal = {Computer Physics Communications},\nvolume = {309},\npages = {109497},\nyear = {2025},\nissn = {0010-4655},\ndoi = {https://doi.org/10.1016/j.cpc.2024.109497},\nurl = {https://www.sciencedirect.com/science/article/pii/S001046552400420X},\nauthor = {Jinyu Wan and Helena Alamprese and Christian Ratcliff and Ji Qiang and Yue Hao}\n}","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"Install Julia at here.\nDownload the package:\n\ngit clone https://github.com/MSU-Beam-Dynamics/JuTrack.jl\n\nSince Julia and its packages are under very active development, it is strongly recommended to create a separate environment for each piece of work.\n\nTo create a \"JuTrack\" environment and install all dependencies (errors may occur if not using this method to install all dependencies):\n\ncd JuTrack.jl\njulia --project=. -e \"using Pkg; Pkg.instantiate()\"","category":"section"},{"location":"#Use-the-package-in-Julia","page":"Home","title":"Use the package in Julia","text":"Activate the JuTrack environment we just created in the Julia code (change below path to your JuTrack directory accordingly):\n\nusing Pkg\nPkg.activate(\"/path/to/JuTrack.jl\") # use the correct Julia environment\nPkg.instantiate()                   # check if all dependencies are correctly installed\n\nImport JuTrack in Julia:\n\nusing JuTrack","category":"section"},{"location":"#Lattice-definition","page":"Home","title":"Lattice definition","text":"D1 = DRIFT(name=\"D1\", len=1.0)\nD2 = DRIFT(name=\"D2\", len=1.0)\nD3 = DRIFT(name=\"D3\", len=1.0)\nD4 = DRIFT(name=\"D4\", len=1.0)\nQ1 = KQUAD(name=\"Q1\", len=1.0, k1=-0.9) \nQ2 = KQUAD(name=\"Q2\", len=1.0, k1=0.3)\nB1 = SBEND(name=\"B1\", len=0.6, angle=pi/15.0)\n\nCreate the lattice as a Julia vector\n\nLINE = [D1, Q1, D2, B1, D3, Q2, D4]","category":"section"},{"location":"#Particle-tracking","page":"Home","title":"Particle tracking","text":"Particles' coordinates are represented as a N * 6 matrix, saved in beam.r\n\nparticles = rand(10, 6) / 1000\nbeam = Beam(particles, energy=3.5e9)\n\nTracking\n\nlinepass!(LINE, beam) # or ringpass!(RING, beam, nturns) for multi-turn tracking\nprintln(beam.r) ","category":"section"},{"location":"#Optics-calculation","page":"Home","title":"Optics calculation","text":"Obtain periodic Twiss parameters of a ring accelerator\n\ntwi = periodicEdwardsTengTwiss(RING, 0.0, 0)","category":"section"},{"location":"#Automatic-differentiation","page":"Home","title":"Automatic differentiation","text":"We provide two options for fast AD calculation, fastTPSA and Enzyme. fastTPSA is a first-order TPSA module, and Enzyme is a third-party package that runs AD at compiler level. Both methods provide comparably fast AD. The fastTPSA is written in pure Julia that is supposed to be more stable. While Enzyme supports all kinds of differentiable functions, which is not limited by the tracking code in JuTrack.\n\nfastTPSA example: Obtain derivatives of tracking result w.r.t the quadrupole strength k1\n\nset_tps_dim(2) # 2 variables for fastTPSA\nfunction tracking_wrt_k1(x1::DTPSAD{NVAR(), Float64}, x2::DTPSAD{NVAR(), Float64})\n    D1 = DRIFT(len=DTPSAD(1.0))        # We use parametric elements in JuTrack.  \n    D2 = DRIFT(len=DTPSAD(1.0))        # When any of the parameters is a DTPSAD type, the element will be ELEMENT{DTPSAD}\n    Q1 = KQUAD(len=DTPSAD(1.0))        # Otherwise, the element will be ELEMENT{Float64}\n    Q2 = KQUAD(len=DTPSAD(1.0))\n\n    Q1.k1 = x1\n    Q2.k1 = x2\n\n    beam = Beam(DTPSAD.([0.1 0.0 0.0 0.0 0.0 0.0]))\n\n    LINE = [D1, Q1, D2, Q2] \n    linepass!(LINE, beam)\n    return beam.r\nend\nk1 = -0.9\nk2 = 0.3\ng, r = Jacobian(tracking_wrt_k1, [k1, k2], true)\n\nEnzyme example: Obtain derivatives of tracking result w.r.t the quadrupole strength k1\n\nfunction tracking_wrt_k1(X)\n    D1 = DRIFT(len=1.0)\n    D2 = DRIFT(len=1.0)\n    Q1 = KQUAD(len=1.0, k1=X[1]) \n    Q2 = KQUAD(len=1.0, k1=X[2])\n\n    beam = Beam([0.1 0.0 0.0 0.0 0.0 0.0])\n\n    LINE = [D1, Q1, D2, Q2] \n    linepass!(LINE, beam)\n    return beam.r\nend\nk1 = -0.9\nk2 = 0.3\nderivatives, results = jacobian(ForwardWithPrimal, tracking_wrt_k1, [k1, k2])","category":"section"},{"location":"#Parallel-computation-setting","page":"Home","title":"Parallel computation setting","text":"Multi-threading is available for multi-particle tracking.  Before using it, please ensure the Julia multi-threading is set up correctly by typing:\n\nprintln(\"Number of threads in use: \", Threads.nthreads())\n\nParallel computing is available for multi-particle tracking using:\n\nplinepass!(beamline, beam)\n\nor \n\npringpass!(beamline, beam, nturns)","category":"section"},{"location":"#Precompile","page":"Home","title":"Precompile","text":"Julia compiles functions the first time they are called (Just-In-Time, JIT). For complex code, this first call can take from seconds to minutes, and the cost repeats every time a new Julia process starts.\n\nA custom sysimage precompiles those methods ahead of time, so loading and running functions has little to no latency, making Julia feel much closer to a traditional compiled language.\n\nWe provide ready-made helper scripts under the precompile/ directory. The file aggwarmup.jl includes some sample functions. Add the function calls you want Julia to precompile in this file, and remove any you don't need to reduce the size of the sysimage.\n\nTest precompile statements. Move to the JuTrack.jl folder, and type\n\nWindows (PowerShell/CMD):\n\njulia --project=. --trace-compile=precompile\\trace_base.jl precompile\\run_warmup.jl\n\nmacOS/Linux:\n\njulia --project=. --trace-compile=precompile/trace_base.jl precompile/run_warmup.jl\n\nBuild the sysimage\n\nWindows:\n\njulia --project=. precompile\\build_sysimage.jl\n\nmacOS/Linux:\n\njulia --project=. precompile/build_sysimage.jl\n\nThis creates precompile/JuTrack_sysimage.(dll|dylib|so) for your platform.\n\nUse it\n\nWindows:\n\njulia --sysimage=precompile\\JuTrack_sysimage.dll your_code.jl\n\nmacOS:\n\njulia --sysimage=precompile/JuTrack_sysimage.dylib your_code.jl\n\nLinux:\n\njulia --sysimage=precompile/JuTrack_sysimage.so your_code.jl","category":"section"},{"location":"#Known-issues","page":"Home","title":"Known issues","text":"JuTrack is actively under development. If you encounter any issues, please open an issue on GitHub or email wan@frib.msu.edu.\nPlease ensure using the same OS and Julia verion when using a precompiled sysimage.","category":"section"}]
}
